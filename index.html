<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Pirate Plunder</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            overflow: hidden;
            touch-action: manipulation;
            font-family: 'Courier New', monospace;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #0f0c29, #302b63);
            margin: 0 auto;
            image-rendering: pixelated;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 18px;
            text-shadow: 2px 2px 2px #000;
            z-index: 10;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 10;
        }
        
        .btn {
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            border-radius: 10px;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #0f0c29, #302b63);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #title {
            font-size: 48px;
            color: #f8c537;
            text-shadow: 4px 4px 0 #a82b2b;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        #startBtn {
            background: #f8c537;
            color: #1a1a2e;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        #startBtn:active {
            transform: scale(0.95);
        }
        
        #levelScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #f8c537;
        }
        
        #levelTitle {
            font-size: 36px;
            margin-bottom: 10px;
        }
        
        #levelDesc {
            font-size: 18px;
            margin-bottom: 30px;
            text-align: center;
            max-width: 80%;
        }
        
        #continueBtn {
            background: #f8c537;
            color: #1a1a2e;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #deathScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #f8c537;
        }
        
        #deathTitle {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        #restartBtn {
            background: #f8c537;
            color: #1a1a2e;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>Gold: <span id="gold">0</span> | Level: <span id="level">1</span></div>
        <div>Health: <span id="health">100</span> | XP: <span id="xp">0</span>/100</div>
    </div>
    
    <div id="controls">
        <div class="btn" id="leftBtn">←</div>
        <div class="btn" id="upBtn">↑</div>
        <div class="btn" id="rightBtn">→</div>
        <div class="btn" id="downBtn">↓</div>
        <div class="btn" id="jumpBtn">JUMP</div>
        <div class="btn" id="attackBtn">ATTACK</div>
    </div>
    
    <div id="titleScreen">
        <div id="title">PIXEL PIRATE PLUNDER</div>
        <button id="startBtn">START ADVENTURE</button>
    </div>
    
    <div id="levelScreen">
        <div id="levelTitle">LEVEL <span id="levelNum">2</span></div>
        <div id="levelDesc">You discover a jungle temple with vine traps and poison dart enemies!</div>
        <button id="continueBtn">CONTINUE</button>
    </div>
    
    <div id="deathScreen">
        <div id="deathTitle">YARR, YE BE SUNK!</div>
        <div id="deathStats"></div>
        <button id="restartBtn">SAIL AGAIN</button>
    </div>

    <script>
        // Game Constants
        const GRAVITY = 0.5;
        const FRICTION = 0.85;
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = -12;
        const DIG_DEPTH = 3;
        
        // Biome Types
        const BIOMES = [
            {
                name: "Beach Caves",
                bgColor: "#0f0c29",
                groundColor: "#5d4037",
                caveColor: "#3a2c1a",
                enemyTypes: [
                    { name: "Crab", color: "#d32f2f", health: 20, speed: 1, damage: 5 },
                    { name: "Seagull", color: "#ffffff", health: 15, speed: 2, damage: 3 }
                ]
            },
            {
                name: "Jungle Temple",
                bgColor: "#1b5e20",
                groundColor: "#4e342e",
                caveColor: "#3e2723",
                enemyTypes: [
                    { name: "Poison Dart", color: "#4caf50", health: 25, speed: 3, damage: 8 },
                    { name: "Vine Trap", color: "#8bc34a", health: 40, speed: 0, damage: 10 }
                ]
            },
            {
                name: "Ice Caverns",
                bgColor: "#0d47a1",
                groundColor: "#b0bec5",
                caveColor: "#78909c",
                enemyTypes: [
                    { name: "Ice Golem", color: "#bbdefb", health: 50, speed: 1, damage: 12 },
                    { name: "Snow Bat", color: "#e3f2fd", health: 20, speed: 4, damage: 6 }
                ]
            },
            {
                name: "Volcano Mines",
                bgColor: "#bf360c",
                groundColor: "#3e2723",
                caveColor: "#212121",
                enemyTypes: [
                    { name: "Lava Slime", color: "#ff5722", health: 30, speed: 2, damage: 15 },
                    { name: "Fire Imp", color: "#ff9800", health: 25, speed: 3, damage: 10 }
                ]
            },
            {
                name: "Ghost Ship",
                bgColor: "#311b92",
                groundColor: "#212121",
                caveColor: "#000000",
                enemyTypes: [
                    { name: "Ghost Pirate", color: "#b39ddb", health: 60, speed: 2, damage: 20 },
                    { name: "Cursed Cannon", color: "#7e57c2", health: 80, speed: 0, damage: 25 }
                ]
            }
        ];
        
        // Game State
        const game = {
            player: {
                x: 100,
                y: 300,
                width: 32,
                height: 48,
                velX: 0,
                velY: 0,
                health: 100,
                maxHealth: 100,
                gold: 0,
                xp: 0,
                level: 1,
                isJumping: false,
                isAttacking: false,
                isDigging: false,
                attackCooldown: 0,
                facing: 'right',
                animationFrame: 0,
                invincible: 0
            },
            camera: {
                x: 0,
                y: 0
            },
            currentBiome: 0,
            platforms: [],
            diggable: [],
            enemies: [],
            treasures: [],
            particles: [],
            isRunning: false,
            isGameOver: false,
            keys: {
                left: false,
                right: false,
                up: false,
                down: false,
                jump: false,
                attack: false
            },
            worldWidth: 3000,
            worldHeight: 800,
            difficulty: 1,
            seed: Math.floor(Math.random() * 10000),
            levelTransition: false,
            turn: 0
        };
        
        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // UI Elements
        const goldDisplay = document.getElementById('gold');
        const healthDisplay = document.getElementById('health');
        const levelDisplay = document.getElementById('level');
        const xpDisplay = document.getElementById('xp');
        const titleScreen = document.getElementById('titleScreen');
        const levelScreen = document.getElementById('levelScreen');
        const levelTitle = document.getElementById('levelTitle');
        const levelDesc = document.getElementById('levelDesc');
        const levelNum = document.getElementById('levelNum');
        const deathScreen = document.getElementById('deathScreen');
        const deathStats = document.getElementById('deathStats');
        
        // Controls
        document.getElementById('leftBtn').addEventListener('touchstart', () => game.keys.left = true);
        document.getElementById('leftBtn').addEventListener('touchend', () => game.keys.left = false);
        document.getElementById('rightBtn').addEventListener('touchstart', () => game.keys.right = true);
        document.getElementById('rightBtn').addEventListener('touchend', () => game.keys.right = false);
        document.getElementById('upBtn').addEventListener('touchstart', () => game.keys.up = true);
        document.getElementById('upBtn').addEventListener('touchend', () => game.keys.up = false);
        document.getElementById('downBtn').addEventListener('touchstart', () => game.keys.down = true);
        document.getElementById('downBtn').addEventListener('touchend', () => game.keys.down = false);
        document.getElementById('jumpBtn').addEventListener('touchstart', () => game.keys.jump = true);
        document.getElementById('jumpBtn').addEventListener('touchend', () => game.keys.jump = false);
        document.getElementById('attackBtn').addEventListener('touchstart', () => game.keys.attack = true);
        
        // Keyboard Controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') game.keys.left = true;
            if (e.key === 'ArrowRight') game.keys.right = true;
            if (e.key === 'ArrowUp') game.keys.up = true;
            if (e.key === 'ArrowDown') game.keys.down = true;
            if (e.key === ' ' || e.key === 'w') game.keys.jump = true;
            if (e.key === 'f' || e.key === 'j') game.keys.attack = true;
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') game.keys.left = false;
            if (e.key === 'ArrowRight') game.keys.right = false;
            if (e.key === 'ArrowUp') game.keys.up = false;
            if (e.key === 'ArrowDown') game.keys.down = false;
            if (e.key === ' ' || e.key === 'w') game.keys.jump = false;
        });
        
        // Game Start/Restart
        document.getElementById('startBtn').addEventListener('click', function() {
            titleScreen.style.display = 'none';
            startGame();
        });
        
        document.getElementById('continueBtn').addEventListener('click', continueGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        
        function startGame() {
            // Reset Game State with new seed
            game.seed = Math.floor(Math.random() * 10000);
            game.difficulty = 1;
            game.player = {
                x: 100,
                y: 300,
                width: 32,
                height: 48,
                velX: 0,
                velY: 0,
                health: 100,
                maxHealth: 100,
                gold: 0,
                xp: 0,
                level: 1,
                isJumping: false,
                isAttacking: false,
                isDigging: false,
                attackCooldown: 0,
                facing: 'right',
                animationFrame: 0,
                invincible: 0
            };
            
            game.camera = { x: 0, y: 0 };
            game.currentBiome = 0;
            game.platforms = [];
            game.diggable = [];
            game.enemies = [];
            game.treasures = [];
            game.particles = [];
            game.isRunning = true;
            game.isGameOver = false;
            game.levelTransition = false;
            game.turn = 0;
            
            // Generate First Level
            generateLevel(0);
            
            // Update UI
            updateUI();
            
            // Start Game Loop
            gameLoop();
        }
        
        function continueGame() {
            levelScreen.style.display = 'none';
            game.levelTransition = false;
            generateLevel(game.currentBiome);
            requestAnimationFrame(gameLoop);
        }
        
        function generateLevel(biomeIndex) {
            const biome = BIOMES[biomeIndex];
            
            // Reset Arrays
            game.platforms = [];
            game.diggable = [];
            game.enemies = [];
            game.treasures = [];
            
            // Set difficulty based on level
            game.difficulty = 1 + (biomeIndex * 0.5);
            
            // Ground (different for each biome)
            game.platforms.push({ 
                x: 0, 
                y: 600, 
                width: game.worldWidth, 
                height: 50,
                color: biome.groundColor
            });
            
            // Use seed for reproducible randomness
            const random = (min, max) => {
                const x = Math.sin(game.seed++) * 10000;
                return min + (x - Math.floor(x)) * (max - min);
            };
            
            // Platforms
            const platformCount = 15 + Math.floor(random(0, 10));
            for (let i = 0; i < platformCount; i++) {
                game.platforms.push({
                    x: random(0, game.worldWidth - 100),
                    y: 400 + random(0, 150),
                    width: 80 + random(0, 100),
                    height: 20,
                    color: biome.groundColor
                });
            }
            
            // Cave Entrances (diggable spots)
            const caveCount = 5 + Math.floor(random(0, 5));
            for (let i = 0; i < caveCount; i++) {
                const cave = {
                    x: 200 + i * 500 + random(-200, 200),
                    y: 550,
                    width: 60,
                    height: 50,
                    color: biome.caveColor,
                    dug: false,
                    treasure: Math.floor(random(50, 200))
                };
                game.diggable.push(cave);
                game.platforms.push(cave); // Also acts as platform
            }
            
            // Treasures
            const treasureCount = 10 + Math.floor(random(0, 10));
            for (let i = 0; i < treasureCount; i++) {
                game.treasures.push({
                    x: random(100, game.worldWidth - 100),
                    y: random(300, 550),
                    width: 20,
                    height: 20,
                    value: 10 + Math.floor(random(0, 40)),
                    type: 'surface'
                });
            }
            
            // Enemies
            const enemyCount = 8 + Math.floor(random(0, 5 * game.difficulty));
            for (let i = 0; i < enemyCount; i++) {
                const type = biome.enemyTypes[Math.floor(random(0, biome.enemyTypes.length))];
                game.enemies.push({
                    x: random(200, game.worldWidth - 200),
                    y: 550,
                    width: 32,
                    height: 48,
                    velX: random(0, 1) > 0.5 ? type.speed : -type.speed,
                    health: type.health * game.difficulty,
                    maxHealth: type.health * game.difficulty,
                    damage: type.damage * game.difficulty,
                    type: type.name,
                    color: type.color,
                    ai: 'patrol'
                });
            }
            
            // Add exit portal at far right
            if (biomeIndex < BIOMES.length - 1) {
                game.treasures.push({
                    x: game.worldWidth - 100,
                    y: 550,
                    width: 40,
                    height: 60,
                    value: 0,
                    type: 'exit'
                });
            } else {
                // Final boss in last level
                game.enemies.push({
                    x: game.worldWidth - 200,
                    y: 400,
                    width: 64,
                    height: 64,
                    velX: 0,
                    health: 200 * game.difficulty,
                    maxHealth: 200 * game.difficulty,
                    damage: 30 * game.difficulty,
                    type: "Pirate King",
                    color: "#d50000",
                    ai: 'boss'
                });
            }
        }
        
        function update() {
            if (game.levelTransition) return;
            
            // Player Movement
            if (game.keys.left) {
                game.player.velX = -PLAYER_SPEED;
                game.player.facing = 'left';
                game.player.animationFrame++;
            } else if (game.keys.right) {
                game.player.velX = PLAYER_SPEED;
                game.player.facing = 'right';
                game.player.animationFrame++;
            } else {
                game.player.velX *= FRICTION;
            }
            
            // Jumping
            if (game.keys.jump && !game.player.isJumping) {
                game.player.velY = JUMP_FORCE;
                game.player.isJumping = true;
                createParticles(game.player.x + game.player.width/2, game.player.y + game.player.height, 10, '#f8c537');
            }
            
            // Digging (when pressing down on diggable spot)
            game.player.isDigging = false;
            if (game.keys.down && !game.player.isJumping) {
                const digSpot = game.diggable.find(spot => 
                    collision(game.player, spot) && !spot.dug);
                
                if (digSpot) {
                    game.player.isDigging = true;
                    digSpot.height -= DIG_DEPTH;
                    if (digSpot.height <= 0) {
                        digSpot.dug = true;
                        // Spawn treasure
                        game.treasures.push({
                            x: digSpot.x + digSpot.width/2 - 15,
                            y: digSpot.y - 30,
                            width: 30,
                            height: 30,
                            value: digSpot.treasure,
                            type: 'chest'
                        });
                        createParticles(digSpot.x + digSpot.width/2, digSpot.y, 20, '#f8c537');
                    }
                }
            }
            
            // Gravity
            game.player.velY += GRAVITY;
            
            // Update Position
            game.player.x += game.player.velX;
            game.player.y += game.player.velY;
            
            // Camera Follow
            game.camera.x = game.player.x - canvas.width/3;
            game.camera.y = Math.min(0, game.player.y - canvas.height/2);
            
            // Boundary Checks
            if (game.player.x < 0) game.player.x = 0;
            if (game.player.x > game.worldWidth - game.player.width) {
                game.player.x = game.worldWidth - game.player.width;
            }
            
            if (game.player.y > game.worldHeight - game.player.height) {
                game.player.y = game.worldHeight - game.player.height;
                game.player.velY = 0;
                game.player.isJumping = false;
            }
            
            // Platform Collisions
            let onGround = false;
            game.platforms.forEach(platform => {
                if (collision(game.player, platform)) {
                    // Top collision
                    if (game.player.velY > 0 && game.player.y + game.player.height < platform.y + 10) {
                        game.player.y = platform.y - game.player.height;
                        game.player.velY = 0;
                        game.player.isJumping = false;
                        onGround = true;
                    }
                    // Bottom collision (when jumping into platform)
                    else if (game.player.velY < 0 && game.player.y > platform.y + platform.height - 10) {
                        game.player.y = platform.y + platform.height;
                        game.player.velY = 0;
                    }
                    // Side collisions
                    else if (game.player.velX > 0) {
                        game.player.x = platform.x - game.player.width;
                        game.player.velX = 0;
                    } else if (game.player.velX < 0) {
                        game.player.x = platform.x + platform.width;
                        game.player.velX = 0;
                    }
                }
            });
            
            if (!onGround) game.player.isJumping = true;
            
            // Attack
            if (game.keys.attack && game.player.attackCooldown <= 0) {
                game.player.isAttacking = true;
                game.player.attackCooldown = 20;
                
                // Check enemy hits
                game.enemies.forEach(enemy => {
                    const attackRange = {
                        x: game.player.facing === 'right' ? game.player.x + game.player.width : game.player.x - 40,
                        y: game.player.y,
                        width: 40,
                        height: game.player.height
                    };
                    
                    if (collision(attackRange, enemy)) {
                        enemy.health -= 25 / game.difficulty;
                        createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 15, '#ff0000');
                        
                        if (enemy.health <= 0) {
                            // Drop gold and XP
                            const xpValue = 10 + Math.floor(enemy.maxHealth / 5);
                            game.player.xp += xpValue;
                            game.treasures.push({
                                x: enemy.x,
                                y: enemy.y,
                                width: 15,
                                height: 15,
                                value: Math.floor(enemy.maxHealth / 3),
                                type: 'gold'
                            });
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 20, '#f8c537');
                        }
                    }
                });
                
                createParticles(
                    game.player.facing === 'right' ? game.player.x + game.player.width : game.player.x - 10,
                    game.player.y + game.player.height/2,
                    8, '#ffffff'
                );
            }
            
            if (game.player.attackCooldown > 0) {
                game.player.attackCooldown--;
            } else {
                game.player.isAttacking = false;
            }
            
            // Enemy AI
            game.enemies = game.enemies.filter(enemy => enemy.health > 0);
            game.enemies.forEach(enemy => {
                // Different AI types
                if (enemy.ai === 'patrol') {
                    enemy.x += enemy.velX;
                    
                    // Simple patrol (turn around at edges)
                    let onEdge = true;
                    game.platforms.forEach(platform => {
                        if (enemy.x + enemy.width > platform.x && enemy.x < platform.x + platform.width &&
                            enemy.y + enemy.height <= platform.y + 5 && enemy.y + enemy.height >= platform.y - 5) {
                            onEdge = false;
                        }
                    });
                    
                    if (onEdge) enemy.velX *= -1;
                } else if (enemy.ai === 'boss') {
                    // Boss charges at player periodically
                    if (game.turn % 120 === 0) {
                        enemy.velX = game.player.x < enemy.x ? -3 : 3;
                    }
                    
                    enemy.x += enemy.velX;
                    enemy.velX *= 0.95;
                }
                
                // Damage player if touching
                if (collision(game.player, enemy) && game.player.invincible <= 0) {
                    game.player.health -= enemy.damage;
                    game.player.invincible = 60;
                    createParticles(game.player.x + game.player.width/2, game.player.y + game.player.height/2, 10, '#ff0000');
                    
                    // Knockback
                    game.player.velX = game.player.x < enemy.x ? -8 : 8;
                    game.player.velY = -5;
                    
                    if (game.player.health <= 0) gameOver();
                }
            });
            
            // Treasure Collection
            game.treasures = game.treasures.filter(treasure => {
                if (collision(game.player, treasure)) {
                    if (treasure.type === 'exit') {
                        // Level complete!
                        game.currentBiome++;
                        if (game.currentBiome >= BIOMES.length) {
                            // Game won!
                            deathStats.innerHTML = `
                                <div>CONGRATULATIONS!</div>
                                <div>You defeated the Pirate King!</div>
                                <div>Total Gold: ${game.player.gold}</div>
                            `;
                            gameOver();
                            return false;
                        } else {
                            // Show level transition
                            levelNum.textContent = game.currentBiome + 1;
                            levelTitle.textContent = `LEVEL ${game.currentBiome + 1}: ${BIOMES[game.currentBiome].name}`;
                            levelDesc.textContent = getLevelDescription(game.currentBiome);
                            levelScreen.style.display = 'flex';
                            game.levelTransition = true;
                            return false;
                        }
                    }
                    
                    game.player.gold += treasure.value;
                    if (treasure.type === 'chest') game.player.xp += 20;
                    createParticles(treasure.x + treasure.width/2, treasure.y + treasure.height/2, 10, '#f8c537');
                    updateUI();
                    return false;
                }
                return true;
            });
            
            // Check level up
            if (game.player.xp >= 100) {
                game.player.level++;
                game.player.maxHealth += 20;
                game.player.health = game.player.maxHealth;
                game.player.xp -= 100;
                createParticles(game.player.x + game.player.width/2, game.player.y, 30, '#00ff00');
                addMessage("Level Up! Health increased!");
                updateUI();
            }
            
            // Update Particles
            game.particles.forEach(p => {
                p.x += p.velX;
                p.y += p.velY;
                p.life--;
            });
            game.particles = game.particles.filter(p => p.life > 0);
            
            // Invincibility frames
            if (game.player.invincible > 0) game.player.invincible--;
            
            // Increment turn counter
            game.turn++;
        }
        
        function getLevelDescription(biomeIndex) {
            const descriptions = [
                "Dig for treasure in sandy caves, but watch out for crabs!",
                "Vines and traps make this temple deadly. Use your sword!",
                "Slippery ice makes movement tricky. Don't fall!",
                "Lava flows everywhere. One wrong step could be your last!",
                "The ghost ship's crew doesn't take kindly to intruders..."
            ];
            return descriptions[biomeIndex];
        }
        
        function render() {
            if (game.levelTransition) return;
            
            const biome = BIOMES[game.currentBiome];
            
            // Clear Canvas
            ctx.fillStyle = biome.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw Parallax Background
            drawBackground(biome);
            
            // Draw World (offset by camera)
            ctx.save();
            ctx.translate(-game.camera.x, -game.camera.y);
            
            // Draw Platforms
            game.platforms.forEach(platform => {
                ctx.fillStyle = platform.color || biome.groundColor;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                
                // Platform detail
                ctx.fillStyle = shadeColor(platform.color || biome.groundColor, -20);
                for (let i = 0; i < platform.width; i += 10) {
                    ctx.fillRect(platform.x + i, platform.y, 5, 3);
                }
            });
            
            // Draw Diggable Caves
            game.diggable.forEach(cave => {
                if (!cave.dug) {
                    // Cave entrance
                    ctx.fillStyle = cave.color;
                    ctx.fillRect(cave.x, cave.y, cave.width, cave.height);
                    
                    // Cave interior shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(cave.x + cave.width/2, cave.y + 10, cave.width/2 - 5, 0, Math.PI, true);
                    ctx.fill();
                    
                    // Shovel icon
                    if (collision(game.player, cave) && game.keys.down) {
                        ctx.fillStyle = '#f8c537';
                        ctx.beginPath();
                        ctx.moveTo(cave.x + cave.width/2 - 5, cave.y + 15);
                        ctx.lineTo(cave.x + cave.width/2 + 5, cave.y + 15);
                        ctx.lineTo(cave.x + cave.width/2, cave.y + 25);
                        ctx.fill();
                    }
                }
            });
            
            // Draw Treasures
            game.treasures.forEach(treasure => {
                if (treasure.type === 'chest') {
                    // Treasure chest
                    ctx.fillStyle = '#f8c537';
                    ctx.fillRect(treasure.x, treasure.y, treasure.width, treasure.height);
                    
                    // Chest details
                    ctx.fillStyle = '#a82b2b';
                    ctx.fillRect(treasure.x + 5, treasure.y + 5, treasure.width - 10, 5);
                    ctx.fillRect(treasure.x + treasure.width/2 - 3, treasure.y - 5, 6, 5);
                    
                    // Shine effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.moveTo(treasure.x + 5, treasure.y + 5);
                    ctx.lineTo(treasure.x + 15, treasure.y + 5);
                    ctx.lineTo(treasure.x + 5, treasure.y + 15);
                    ctx.fill();
                } else if (treasure.type === 'exit') {
                    // Exit portal
                    ctx.fillStyle = '#00bcd4';
                    ctx.beginPath();
                    ctx.arc(treasure.x + treasure.width/2, treasure.y + treasure.height/2, treasure.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(treasure.x + treasure.width/2, treasure.y + treasure.height/2, treasure.width/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#00bcd4';
                    ctx.font = '16px monospace';
                    ctx.fillText("EXIT", treasure.x + 5, treasure.y + 35);
                } else {
                    // Gold coins
                    ctx.fillStyle = '#f8c537';
                    ctx.beginPath();
                    ctx.arc(treasure.x + treasure.width/2, treasure.y + treasure.height/2, treasure.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = shadeColor('#f8c537', -20);
                    ctx.beginPath();
                    ctx.arc(treasure.x + treasure.width/2 - 2, treasure.y + treasure.height/2 - 2, treasure.width/3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw Enemies
            game.enemies.forEach(enemy => {
                // Body
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // Enemy-specific details
                if (enemy.type.includes("Crab")) {
                    // Claws
                    ctx.fillStyle = shadeColor(enemy.color, -20);
                    ctx.fillRect(enemy.x - 5, enemy.y + 10, 5, 10);
                    ctx.fillRect(enemy.x + enemy.width, enemy.y + 10, 5, 10);
                } else if (enemy.type.includes("Ghost")) {
                    // Ghostly aura
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    ctx.globalAlpha = 1;
                    
                    // Chains
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(enemy.x + enemy.width/2 + (i - 1) * 10, enemy.y - 5 - i * 5, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Health bar
                const healthPercent = enemy.health / enemy.maxHealth;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 3);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * healthPercent, 3);
            });
            
            // Draw Player
            drawPlayer();
            
            // Draw Particles
            game.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;
            
            ctx.restore();
        }
        
        function drawPlayer() {
            const p = game.player;
            const frame = Math.floor(p.animationFrame / 10) % 4;
const invincibleFlash = p.invincible > 0 && Math.floor(p.invincible / 5) % 2 === 0;
            
            ctx.save();
            ctx.translate(p.x, p.y);
            
            if (invincibleFlash) {
                ctx.globalAlpha = 0.5;
            }
            
            // Body (coat) - animated when moving
            ctx.fillStyle = '#8d6e63';
            if (p.velX !== 0 && !p.isJumping) {
                // Walking animation
                const legOffset = [0, 2, 0, -2][frame];
                ctx.fillRect(0, 10 + legOffset, p.width, p.height - 10);
            } else {
                // Standing/jumping
                ctx.fillRect(0, 10, p.width, p.height - 10);
            }
            
            // Head
            ctx.fillStyle = '#ffdbac';
            ctx.fillRect(8, 0, 16, 10);
            
            // Facial features
            ctx.fillStyle = '#000000';
            if (p.facing === 'right') {
                // Right-facing (eye patch on left eye)
                ctx.fillRect(12, 3, 6, 3); // Eye patch
                ctx.fillRect(20, 3, 2, 2); // Eye
            } else {
                // Left-facing (eye patch on right eye)
                ctx.fillRect(18, 3, 6, 3); // Eye patch
                ctx.fillRect(10, 3, 2, 2); // Eye
            }
            
            // Hat
            ctx.fillStyle = '#a82b2b';
            ctx.fillRect(4, -5, 24, 5); // Hat brim
            ctx.fillRect(12, -15, 8, 10); // Hat top
            
            // Beard
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(10, 8, 12, 4);
            
            // Arms (animated when moving or attacking)
            if (p.isAttacking) {
                // Attack pose
                ctx.fillStyle = '#8d6e63';
                if (p.facing === 'right') {
                    ctx.fillRect(p.width, 15, 30, 5); // Sword arm extended right
                    ctx.fillRect(-10, 15, 10, 5); // Left arm
                } else {
                    ctx.fillRect(-30, 15, 30, 5); // Sword arm extended left
                    ctx.fillRect(p.width, 15, 10, 5); // Right arm
                }
                
                // Sword
                ctx.fillStyle = '#cccccc';
                if (p.facing === 'right') {
                    ctx.fillRect(p.width + 25, 10, 5, 15);
                } else {
                    ctx.fillRect(-30, 10, 5, 15);
                }
            } else if (p.velX !== 0 && !p.isJumping) {
                // Walking animation
                ctx.fillStyle = '#8d6e63';
                const armOffset = [0, 2, 0, -2][frame];
                ctx.fillRect(-5, 15 + armOffset, 5, 5); // Left arm
                ctx.fillRect(p.width, 15 - armOffset, 5, 5); // Right arm
            } else {
                // Standing pose
                ctx.fillStyle = '#8d6e63';
                ctx.fillRect(-5, 15, 5, 5); // Left arm
                ctx.fillRect(p.width, 15, 5, 5); // Right arm
            }
            
            // Legs (jumping animation)
            ctx.fillStyle = '#5d4037';
            if (p.isJumping) {
                ctx.fillRect(5, p.height - 5, 8, 5);
                ctx.fillRect(19, p.height - 5, 8, 5);
            } else if (p.velX !== 0) {
                // Walking animation
                const leg1 = [0, 2, 0, -2][frame];
                const leg2 = [-2, 0, 2, 0][frame];
                ctx.fillRect(5, p.height - 5 + leg1, 8, 5);
                ctx.fillRect(19, p.height - 5 + leg2, 8, 5);
            } else {
                // Standing
                ctx.fillRect(5, p.height - 5, 8, 5);
                ctx.fillRect(19, p.height - 5, 8, 5);
            }
            
            // Digging animation
            if (p.isDigging) {
                ctx.fillStyle = '#f8c537';
                ctx.beginPath();
                ctx.moveTo(p.width/2 - 5, p.height + 5);
                ctx.lineTo(p.width/2 + 5, p.height + 5);
                ctx.lineTo(p.width/2, p.height + 15);
                ctx.fill();
            }
            
            ctx.restore();
        }

        function drawBackground(biome) {
            // Stars (for night levels)
            if (biome.bgColor === '#0f0c29' || biome.bgColor === '#311b92') {
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 100; i++) {
                    const x = (i * 50 + game.camera.x * 0.1) % canvas.width;
                    const y = (i * 37) % canvas.height;
                    const size = 1 + Math.random();
                    ctx.fillRect(x, y, size, size);
                }
            }
            
            // Moon (for night levels)
            if (biome.bgColor === '#0f0c29') {
                ctx.fillStyle = '#f5f5f5';
                ctx.beginPath();
                ctx.arc(canvas.width - 100 - game.camera.x * 0.05, 100, 30, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Sun (for day levels)
            if (biome.bgColor === '#1b5e20' || biome.bgColor === '#0d47a1') {
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.arc(canvas.width - 100 - game.camera.x * 0.05, 100, 40, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Distant Mountains
            ctx.fillStyle = shadeColor(biome.bgColor, -30);
            ctx.beginPath();
            ctx.moveTo(0 - game.camera.x * 0.2, canvas.height);
            for (let i = 0; i < 5; i++) {
                const x = i * 200 - game.camera.x * 0.2;
                const height = 100 + Math.sin(i) * 50;
                ctx.lineTo(x, canvas.height - height);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fill();
            
            // Closer Hills
            ctx.fillStyle = shadeColor(biome.bgColor, -15);
            ctx.beginPath();
            ctx.moveTo(0 - game.camera.x * 0.4, canvas.height);
            for (let i = 0; i < 8; i++) {
                const x = i * 150 - game.camera.x * 0.4;
                const height = 50 + Math.sin(i * 1.5) * 30;
                ctx.lineTo(x, canvas.height - height);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fill();
        }

        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x: x,
                    y: y,
                    size: 2 + Math.random() * 4,
                    velX: -2 + Math.random() * 4,
                    velY: -2 + Math.random() * 4,
                    color: color,
                    life: 10 + Math.random() * 20,
                    maxLife: 30
                });
            }
        }

        function collision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function shadeColor(color, percent) {
            // Helper function to lighten/darken colors
            let R = parseInt(color.substring(1,3), 16);
            let G = parseInt(color.substring(3,5), 16);
            let B = parseInt(color.substring(5,7), 16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = (R<255)?R:255;  
            G = (G<255)?G:255;  
            B = (B<255)?B:255;  

            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16);
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16);
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16);

            return "#"+RR+GG+BB;
        }

        function updateUI() {
            goldDisplay.textContent = game.player.gold;
            healthDisplay.textContent = Math.floor(game.player.health);
            levelDisplay.textContent = game.player.level;
            xpDisplay.textContent = game.player.xp;
        }

        function addMessage(text) {
            // For future message system
            console.log(text);
        }

        function gameOver() {
            game.isRunning = false;
            game.isGameOver = true;
            deathStats.innerHTML = `
                <div>Gold Collected: ${game.player.gold}</div>
                <div>Level Reached: ${game.currentBiome + 1}</div>
                <div>Player Level: ${game.player.level}</div>
            `;
            deathScreen.style.display = 'flex';
        }

        // Initialize the game
        titleScreen.style.display = 'flex';
        deathScreen.style.display = 'none';
        levelScreen.style.display = 'none';

        // Main Game Loop
        function gameLoop() {
            if (game.isRunning && !game.levelTransition) {
                update();
                render();
                requestAnimationFrame(gameLoop);
            }
        }
    </script>

<script>
let canvas, ctx;
let player = {
  x: 100,
  y: 300,
  width: 40,
  height: 40,
  vy: 0,
  gravity: 1,
  jumpPower: -15,
  grounded: false,
  color: "orange"
};
let keys = {};
let gameRunning = false;

function setupGameCanvas() {
  canvas = document.getElementById("gameCanvas");
  ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function startGame() {
  document.getElementById("startScreen").style.display = "none";
  setupGameCanvas();
  gameRunning = true;
  gameLoop();
}

function gameLoop() {
  if (!gameRunning) return;
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

function update() {
  player.vy += player.gravity;
  player.y += player.vy;

  if (player.y + player.height >= canvas.height - 50) {
    player.y = canvas.height - 50 - player.height;
    player.vy = 0;
    player.grounded = true;
  }

  if (keys["ArrowUp"] && player.grounded) {
    player.vy = player.jumpPower;
    player.grounded = false;
  }

  if (keys["ArrowRight"]) {
    player.x += 5;
  }
  if (keys["ArrowLeft"]) {
    player.x -= 5;
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#1a1a2e";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Ground
  ctx.fillStyle = "#00cc00";
  ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

  // Player
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.width, player.height);
}

window.addEventListener("keydown", (e) => { keys[e.key] = true; });
window.addEventListener("keyup", (e) => { keys[e.key] = false; });
</script>

</body>
</html>
