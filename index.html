<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pirate Quest</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            touch-action: manipulation;
            font-family: 'Arial', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
            image-rendering: pixelated;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 16px;
            text-shadow: 2px 2px 4px #000;
            z-index: 100;
            pointer-events: none;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            box-sizing: border-box;
            z-index: 100;
            opacity: 0.8;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            width: 60px;
            height: 60px;
            background: rgba(50, 50, 50, 0.7);
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #action-btns .btn {
            background: rgba(200, 50, 50, 0.7);
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: #fff;
        }
        
        #title {
            font-size: 48px;
            color: #f8c537;
            text-shadow: 0 0 10px #f8c537, 0 0 20px #f8c537;
            margin-bottom: 30px;
            animation: pulse 2s infinite;
            font-family: 'Pirata One', cursive;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .menu-btn {
            background: linear-gradient(to bottom, #f8c537, #daa520);
            color: #1a1a2e;
            border: none;
            padding: 12px 25px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s;
            box-shadow: 0 4px 0 #a82b2b;
        }
        
        .menu-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #a82b2b;
        }
        
        #levelScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: #fff;
            text-align: center;
        }
        
        #levelTitle {
            font-size: 36px;
            margin-bottom: 10px;
            color: #f8c537;
            font-family: 'Pirata One', cursive;
        }
        
        #levelDesc {
            font-size: 18px;
            margin-bottom: 30px;
            max-width: 80%;
            line-height: 1.5;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: #fff;
        }
        
        #gameOverTitle {
            font-size: 48px;
            margin-bottom: 20px;
            color: #f8c537;
            font-family: 'Pirata One', cursive;
        }
        
        .stats {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 10px;
            width: 80%;
            max-width: 300px;
        }
        
        #healthBar {
            height: 20px;
            background: linear-gradient(to right, #ff0000, #ff4500);
            border: 2px solid #fff;
            border-radius: 10px;
            margin-top: 5px;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        
        #healthBarContainer {
            width: 150px;
            margin-top: 5px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 3px;
        }
        
        #powerupIndicator {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 14px;
            text-shadow: 1px 1px 2px #000;
            z-index: 100;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 15px;
            display: none;
        }
        
        @font-face {
            font-family: 'Pirata One';
            src: url('https://fonts.googleapis.com/css2?family=Pirata+One&display=swap');
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Pirata+One&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div>Gold: <span id="gold">0</span> | Level: <span id="level">1</span></div>
        <div>Health: <span id="health">100</span></div>
        <div id="healthBarContainer">
            <div id="healthBar" style="width: 100%;"></div>
        </div>
        <div id="powerupIndicator"></div>
    </div>
    
    <div id="controls">
        <div class="control-group">
            <div class="btn" id="leftBtn">←</div>
            <div class="btn" id="rightBtn">→</div>
        </div>
        <div class="control-group" id="action-btns">
            <div class="btn" id="jumpBtn">↑</div>
            <div class="btn" id="attackBtn">⚔️</div>
        </div>
    </div>
    
    <div id="titleScreen">
        <div id="title">PIRATE QUEST</div>
        <button class="menu-btn" id="startBtn">BEGIN ADVENTURE</button>
        <button class="menu-btn" id="howToPlayBtn">HOW TO PLAY</button>
    </div>
    
    <div id="levelScreen">
        <div id="levelTitle">LEVEL <span id="levelNum">2</span></div>
        <div id="levelDesc"></div>
        <button class="menu-btn" id="continueBtn">CONTINUE</button>
    </div>
    
    <div id="gameOverScreen">
        <div id="gameOverTitle">GAME OVER</div>
        <div class="stats" id="gameStats"></div>
        <button class="menu-btn" id="restartBtn">TRY AGAIN</button>
        <button class="menu-btn" id="menuBtn">MAIN MENU</button>
    </div>

<script>
document.addEventListener("DOMContentLoaded", function () {
    // Game elements
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // UI elements
    const goldDisplay = document.getElementById("gold");
    const levelDisplay = document.getElementById("level");
    const healthDisplay = document.getElementById("health");
    const healthBar = document.getElementById("healthBar");
    const powerupIndicator = document.getElementById("powerupIndicator");
    const titleScreen = document.getElementById("titleScreen");
    const levelScreen = document.getElementById("levelScreen");
    const levelTitle = document.getElementById("levelTitle");
    const levelDesc = document.getElementById("levelDesc");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const gameStats = document.getElementById("gameStats");
    const startBtn = document.getElementById("startBtn");
    const howToPlayBtn = document.getElementById("howToPlayBtn");
    const continueBtn = document.getElementById("continueBtn");
    const restartBtn = document.getElementById("restartBtn");
    const menuBtn = document.getElementById("menuBtn");
    
    // Control buttons
    const leftBtn = document.getElementById("leftBtn");
    const rightBtn = document.getElementById("rightBtn");
    const jumpBtn = document.getElementById("jumpBtn");
    const attackBtn = document.getElementById("attackBtn");
    
    // Game state
    let gameStarted = false;
    let gameOver = false;
    let levelComplete = false;
    let levelTransition = false;
    let currentLevel = 1;
    const maxLevel = 3;
    let score = 0;
    let enemiesDefeated = 0;
    
    // Background layers for parallax
    let backgrounds = [];
    
    // Player properties
    const player = {
        x: 100,
        y: 300,
        width: 40,
        height: 60,
        vy: 0,
        vx: 0,
        gravity: 0.5,
        jumpPower: -16,
        grounded: false,
        speed: 6,
        maxHealth: 100,
        health: 100,
        gold: 0,
        xp: 0,
        level: 1,
        xpToNextLevel: 100,
        facing: 1, // 1 for right, -1 for left
        attacking: false,
        attackCooldown: 0,
        attackDuration: 15,
        attackRange: 70,
        damage: 20,
        invincible: false,
        invincibleTimer: 0,
        powerup: null,
        powerupTimer: 0,
        color: "#f8c537",
        sprite: null,
        attackSprite: null
    };
    
    // Game objects
    let platforms = [];
    let enemies = [];
    let coins = [];
    let treasures = [];
    let projectiles = [];
    let traps = [];
    let powerups = [];
    let levelExit = null;
    
    // Keys and controls
    const keys = {
        ArrowLeft: false,
        ArrowRight: false,
        ArrowUp: false,
        Space: false,
        KeyZ: false
    };
    
    // Powerup types
    const POWERUP_TYPES = {
        HEALTH: { color: "#ff0000", effect: "Full Health" },
        DOUBLE_JUMP: { color: "#00ff00", effect: "Double Jump" },
        FIRE_ATTACK: { color: "#ff4500", effect: "Fire Attack" },
        INVINCIBILITY: { color: "#ffff00", effect: "Invincibility" }
    };
    
    // Level descriptions
    const LEVEL_DESCRIPTIONS = [
        "", // Level 0 doesn't exist
        "Tropical Island: Navigate the beaches and cliffs to find the pirate treasure!",
        "Jungle Temple: Deadly traps and ancient guardians protect the jungle's secrets!",
        "Ghost Ship: Battle spectral pirates on the haunted vessel to claim your reward!"
    ];
    
    // Create sprites
    function createSprites() {
        // Player sprite
        const playerCanvas = document.createElement("canvas");
        playerCanvas.width = 40;
        playerCanvas.height = 60;
        const playerCtx = playerCanvas.getContext("2d");
        
        // Body
        playerCtx.fillStyle = player.color;
        playerCtx.fillRect(5, 10, 30, 40);
        
        // Head
        playerCtx.fillStyle = "#ffdbac";
        playerCtx.fillRect(10, 0, 20, 20);
        
        // Eyes
        playerCtx.fillStyle = "#1a1a2e";
        playerCtx.fillRect(14, 8, 4, 4);
        playerCtx.fillRect(22, 8, 4, 4);
        
        // Bandana
        playerCtx.fillStyle = "#a82b2b";
        playerCtx.fillRect(10, 0, 20, 5);
        playerCtx.beginPath();
        playerCtx.moveTo(10, 5);
        playerCtx.lineTo(5, 10);
        playerCtx.lineTo(15, 10);
        playerCtx.closePath();
        playerCtx.fill();
        
        // Sword
        playerCtx.fillStyle = "#ccc";
        playerCtx.fillRect(35, 15, 5, 30);
        playerCtx.fillStyle = "#f8c537";
        playerCtx.fillRect(40, 15, 5, 5);
        
        player.sprite = playerCanvas;
        
        // Attack sprite
        const attackCanvas = document.createElement("canvas");
        attackCanvas.width = 70;
        attackCanvas.height = 60;
        const attackCtx = attackCanvas.getContext("2d");
        
        // Sword slash effect
        attackCtx.fillStyle = "rgba(255, 200, 0, 0.7)";
        attackCtx.beginPath();
        attackCtx.moveTo(40, 0);
        attackCtx.lineTo(70, 30);
        attackCtx.lineTo(40, 60);
        attackCtx.closePath();
        attackCtx.fill();
        
        player.attackSprite = attackCanvas;
    }
    
    // Create background layers
    function createBackgrounds() {
        backgrounds = [];
        
        // Different backgrounds for each level
        if (currentLevel === 1) {
            // Tropical island
            createLayer("#87CEEB", 0.2); // Sky
            createLayer("#1E90FF", 0.4); // Distant ocean
            createLayer("#4682B4", 0.6); // Near ocean
            createLayer("#2E8B57", 0.8); // Distant island
            createLayer("#228B22", 1.0); // Near island
        } 
        else if (currentLevel === 2) {
            // Jungle temple
            createLayer("#1E90FF", 0.1); // Sky
            createLayer("#006400", 0.3); // Distant jungle
            createLayer("#2E8B57", 0.6); // Mid jungle
            createLayer("#228B22", 0.9); // Near jungle
            createLayer("#8B4513", 1.0); // Ground
        } 
        else if (currentLevel === 3) {
            // Ghost ship
            createLayer("#000033", 0.1); // Night sky
            createLayer("#000066", 0.3); // Distant waves
            createLayer("#000080", 0.6); // Mid waves
            createLayer("#00008B", 0.9); // Near waves
            createLayer("#191970", 1.0); // Ship deck
        }
        
        function createLayer(color, speed) {
            const canvas = document.createElement("canvas");
            canvas.width = canvas.width;
            canvas.height = canvas.height;
            const ctx = canvas.getContext("2d");
            
            // Fill with color
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add some details based on level
            if (currentLevel === 1) {
                // Tropical details (clouds, palm trees)
                ctx.fillStyle = "#FFFFFF";
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height * 0.5;
                    const size = 20 + Math.random() * 30;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } 
            else if (currentLevel === 2) {
                // Jungle details (trees, vines)
                ctx.fillStyle = "#003300";
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * canvas.width;
                    const width = 10 + Math.random() * 20;
                    const height = 50 + Math.random() * 100;
                    ctx.fillRect(x, canvas.height - height, width, height);
                }
            } 
            else if (currentLevel === 3) {
                // Ghost ship details (stars, waves)
                ctx.fillStyle = "#FFFFFF";
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height * 0.5;
                    const size = 1 + Math.random() * 2;
                    ctx.fillRect(x, y, size, size);
                }
            }
            
            backgrounds.push({ canvas, speed });
        }
    }
    
    // Initialize game
    function initGame() {
        createSprites();
        setupControls();
        setupEventListeners();
        loadLevel(currentLevel);
        updateUI();
    }
    
    // Set up touch controls
    function setupControls() {
        leftBtn.addEventListener("touchstart", () => { keys.ArrowLeft = true; });
        leftBtn.addEventListener("touchend", () => { keys.ArrowLeft = false; });
        leftBtn.addEventListener("mousedown", () => { keys.ArrowLeft = true; });
        leftBtn.addEventListener("mouseup", () => { keys.ArrowLeft = false; });
        
        rightBtn.addEventListener("touchstart", () => { keys.ArrowRight = true; });
        rightBtn.addEventListener("touchend", () => { keys.ArrowRight = false; });
        rightBtn.addEventListener("mousedown", () => { keys.ArrowRight = true; });
        rightBtn.addEventListener("mouseup", () => { keys.ArrowRight = false; });
        
        jumpBtn.addEventListener("touchstart", () => { keys.ArrowUp = true; });
        jumpBtn.addEventListener("touchend", () => { keys.ArrowUp = false; });
        jumpBtn.addEventListener("mousedown", () => { keys.ArrowUp = true; });
        jumpBtn.addEventListener("mouseup", () => { keys.ArrowUp = false; });
        
        attackBtn.addEventListener("touchstart", () => { keys.KeyZ = true; });
        attackBtn.addEventListener("touchend", () => { keys.KeyZ = false; });
        attackBtn.addEventListener("mousedown", () => { keys.KeyZ = true; });
        attackBtn.addEventListener("mouseup", () => { keys.KeyZ = false; });
    }
    
    // Set up event listeners
    function setupEventListeners() {
        startBtn.addEventListener("click", startGame);
        howToPlayBtn.addEventListener("click", showHowToPlay);
        continueBtn.addEventListener("click", continueToNextLevel);
        restartBtn.addEventListener("click", restartGame);
        menuBtn.addEventListener("click", returnToMenu);
        
        window.addEventListener("keydown", (e) => {
            if (e.code in keys) {
                keys[e.code] = true;
                e.preventDefault();
            }
        });
        
        window.addEventListener("keyup", (e) => {
            if (e.code in keys) {
                keys[e.code] = false;
                e.preventDefault();
            }
        });
        
        window.addEventListener("resize", () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createBackgrounds();
        });
    }
    
    // Generate random level elements
    function generateLevelElements() {
        const platformHeight = 20;
        const platformColor = currentLevel === 1 ? "#8B4513" : 
                            currentLevel === 2 ? "#5D4037" : "#3E2723";
        
        // Generate platforms
        const numPlatforms = 5 + currentLevel * 2;
        const minPlatformWidth = 80;
        const maxPlatformWidth = 120 + currentLevel * 20;
        const platformSpacing = canvas.width / (numPlatforms + 1);
        
        for (let i = 0; i < numPlatforms; i++) {
            const width = minPlatformWidth + Math.random() * (maxPlatformWidth - minPlatformWidth);
            const x = platformSpacing * (i + 0.5 + Math.random() * 0.4 - 0.2) - width / 2;
            const y = canvas.height - 150 - i * 80 + (Math.random() * 60 - 30);
            
            platforms.push({
                x, y, 
                width, 
                height: platformHeight, 
                color: platformColor
            });
        }
        
        // Generate coins (more coins in higher levels)
        const numCoins = 10 + currentLevel * 5;
        for (let i = 0; i < numCoins; i++) {
            coins.push({
                x: Math.random() * (canvas.width - 40) + 20,
                y: Math.random() * (canvas.height - 200) + 50,
                width: 20,
                height: 20,
                value: 5 + currentLevel * 2,
                collected: false,
                animation: Math.random() * Math.PI * 2
            });
        }
        
        // Generate treasures (more valuable in higher levels)
        const numTreasures = 2 + currentLevel;
        for (let i = 0; i < numTreasures; i++) {
            treasures.push({
                x: Math.random() * (canvas.width - 60) + 30,
                y: Math.random() * (canvas.height - 300) + 100,
                width: 30,
                height: 25,
                value: 50 + currentLevel * 25,
                collected: false,
                glow: 0
            });
        }
        
        // Generate enemies (more and stronger in higher levels)
        const numEnemies = 2 + currentLevel;
        for (let i = 0; i < numEnemies; i++) {
            const type = Math.random() > 0.7 ? "shooter" : "melee";
            const health = 30 + currentLevel * 10;
            const damage = 10 + currentLevel * 5;
            const speed = 1.5 + currentLevel * 0.5;
            
            enemies.push({
                x: Math.random() * (canvas.width - 100) + 50,
                y: canvas.height - 100,
                width: 40,
                height: 50,
                speed,
                health,
                maxHealth: health,
                damage,
                direction: Math.random() > 0.5 ? 1 : -1,
                color: currentLevel === 1 ? "#a82b2b" : 
                      currentLevel === 2 ? "#006400" : "#4B0082",
                type,
                shoots: type === "shooter",
                shootCooldown: type === "shooter" ? Math.floor(Math.random() * 60) : 0,
                shootInterval: 120 - currentLevel * 20,
                projectileSpeed: 5 + currentLevel,
                animation: 0
            });
        }
        
        // Generate traps (more dangerous in higher levels)
        if (currentLevel > 1) {
            const numTraps = currentLevel;
            for (let i = 0; i < numTraps; i++) {
                traps.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: 0,
                    width: 30,
                    height: 30,
                    active: false,
                    timer: Math.floor(Math.random() * 60),
                    interval: 120 - currentLevel * 20,
                    direction: "down",
                    speed: 8 + currentLevel,
                    damage: 15 + currentLevel * 5,
                    type: currentLevel === 2 ? "dart" : "rock"
                });
            }
        }
        
        // Generate powerups (more rare in higher levels)
        if (Math.random() > 0.7 - currentLevel * 0.1) {
            const powerupTypes = Object.keys(POWERUP_TYPES);
            const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
            
            powerups.push({
                x: Math.random() * (canvas.width - 60) + 30,
                y: Math.random() * (canvas.height - 200) + 100,
                width: 30,
                height: 30,
                type: randomType,
                color: POWERUP_TYPES[randomType].color,
                collected: false,
                animation: 0
            });
        }
        
        // Level exit
        levelExit = {
            x: canvas.width - 100,
            y: canvas.height - 100 - 60,
            width: 50,
            height: 60,
            color: "#4169E1",
            animation: 0
        };
    }
    
    // Load level
    function loadLevel(level) {
        // Reset game objects
        platforms = [];
        enemies = [];
        coins = [];
        treasures = [];
        projectiles = [];
        traps = [];
        powerups = [];
        levelExit = null;
        
        // Reset player position and state
        player.x = 100;
        player.y = 300;
        player.vy = 0;
        player.vx = 0;
        player.grounded = false;
        player.attacking = false;
        player.attackCooldown = 0;
        player.invincible = false;
        player.invincibleTimer = 0;
        player.powerup = null;
        player.powerupTimer = 0;
        
        // Set current level
        currentLevel = level;
        
        // Create backgrounds
        createBackgrounds();
        
        // Generate level elements
        generateLevelElements();
        
        // Update level description
        levelDesc.textContent = LEVEL_DESCRIPTIONS[currentLevel];
    }
    
    // Start game
    function startGame() {
        titleScreen.style.display = "none";
        gameStarted = true;
        gameOver = false;
        levelComplete = false;
        levelTransition = false;
        currentLevel = 1;
        score = 0;
        enemiesDefeated = 0;
        
        // Reset player stats
        player.health = player.maxHealth;
        player.gold = 0;
        player.level = 1;
        player.xp = 0;
        player.xpToNextLevel = 100;
        
        loadLevel(currentLevel);
        updateUI();
        gameLoop();
    }
    
    // Show how to play
    function showHowToPlay() {
        levelDesc.textContent = "Controls:\n← → to move\n↑ to jump\n⚔️ to attack\n\nCollect gold and treasures!\nAvoid enemies and traps!\nFind the exit to advance!";
        levelTitle.textContent = "HOW TO PLAY";
        titleScreen.style.display = "none";
        levelScreen.style.display = "flex";
        continueBtn.textContent = "GOT IT";
        continueBtn.onclick = () => {
            levelScreen.style.display = "none";
            titleScreen.style.display = "flex";
            levelTitle.textContent = `LEVEL ${currentLevel}`;
            levelDesc.textContent = LEVEL_DESCRIPTIONS[currentLevel];
            continueBtn.textContent = "CONTINUE";
            continueBtn.onclick = continueToNextLevel;
        };
    }
    
    // Continue to next level
    function continueToNextLevel() {
        levelScreen.style.display = "none";
        levelTransition = false;
        loadLevel(currentLevel);
        gameLoop();
    }
    
    // Restart game
    function restartGame() {
        gameOverScreen.style.display = "none";
        startGame();
    }
    
    // Return to menu
    function returnToMenu() {
        gameOverScreen.style.display = "none";
        titleScreen.style.display = "flex";
    }
    
    // Show level screen
    function showLevelScreen() {
        levelTransition = true;
        levelTitle.textContent = `LEVEL ${currentLevel}`;
        levelScreen.style.display = "flex";
    }
    
    // Show game over screen
    function showGameOverScreen(victory = false) {
        gameOver = true;
        
        if (victory) {
            gameOverTitle.textContent = "VICTORY!";
            gameStats.innerHTML = `
                <div>Final Score: ${score}</div>
                <div>Gold Collected: ${player.gold}</div>
                <div>Enemies Defeated: ${enemiesDefeated}</div>
                <div>Levels Completed: ${currentLevel - 1}</div>
            `;
        } else {
            gameOverTitle.textContent = "GAME OVER";
            gameStats.innerHTML = `
                <div>Score: ${score}</div>
                <div>Gold Collected: ${player.gold}</div>
                <div>Level Reached: ${currentLevel}</div>
                <div>Enemies Defeated: ${enemiesDefeated}</div>
            `;
        }
        
        gameOverScreen.style.display = "flex";
    }
    
    // Apply powerup effect
    function applyPowerup(type) {
        player.powerup = type;
        player.powerupTimer = 600; // 10 seconds
        
        switch (type) {
            case "HEALTH":
                player.health = player.maxHealth;
                powerupIndicator.textContent = "FULL HEALTH!";
                break;
            case "DOUBLE_JUMP":
                powerupIndicator.textContent = "DOUBLE JUMP!";
                break;
            case "FIRE_ATTACK":
                powerupIndicator.textContent = "FIRE ATTACK!";
                break;
            case "INVINCIBILITY":
                player.invincible = true;
                player.invincibleTimer = 600;
                powerupIndicator.textContent = "INVINCIBILITY!";
                break;
        }
        
        powerupIndicator.style.display = "block";
        powerupIndicator.style.backgroundColor = POWERUP_TYPES[type].color;
        updateUI();
    }
    
    // Update powerups
    function updatePowerups() {
        if (player.powerup) {
            player.powerupTimer--;
            
            if (player.powerupTimer <= 0) {
                // Powerup expired
                if (player.powerup === "INVINCIBILITY") {
                    player.invincible = false;
                    player.invincibleTimer = 0;
                }
                
                player.powerup = null;
                powerupIndicator.style.display = "none";
            } else if (player.powerupTimer % 30 === 0) {
                // Flash warning when about to expire
                powerupIndicator.style.display = 
                    powerupIndicator.style.display === "none" ? "block" : "none";
            }
        }
    }
    
    // Update game state
    function update() {
        if (gameOver || levelTransition) return;
        
        // Player movement
        player.vx = 0;
        
        if (keys.ArrowLeft) {
            player.vx = -player.speed;
            player.facing = -1;
        }
        if (keys.ArrowRight) {
            player.vx = player.speed;
            player.facing = 1;
        }
        
        // Jumping
        if ((keys.ArrowUp || keys.Space) && (player.grounded || 
            (player.powerup === "DOUBLE_JUMP" && player.vy < 0))) {
            player.vy = player.jumpPower;
            player.grounded = false;
        }
        
        // Attacking
        if (keys.KeyZ && player.attackCooldown <= 0) {
            player.attacking = true;
            player.attackCooldown = player.attackDuration + 20;
        }
        
        // Update attack state
        if (player.attacking) {
            if (player.attackCooldown <= player.attackDuration) {
                player.attacking = false;
            }
        }
        
        if (player.attackCooldown > 0) {
            player.attackCooldown--;
        }
        
        // Update invincibility
        if (player.invincible) {
            player.invincibleTimer--;
            if (player.invincibleTimer <= 0) {
                player.invincible = false;
            }
        }
        
        // Update powerups
        updatePowerups();
        
        // Apply gravity
        player.vy += player.gravity;
        
        // Update position
        player.x += player.vx;
        player.y += player.vy;
        
        // Screen boundaries
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > canvas.width) {
            player.x = canvas.width - player.width;
        }
        
        // Platform collision
        player.grounded = false;
        for (const platform of platforms) {
            if (player.x + player.width > platform.x &&
                player.x < platform.x + platform.width &&
                player.y + player.height > platform.y &&
                player.y < platform.y + platform.height) {
                
                // Landing on top of platform
                if (player.vy > 0 && player.y + player.height < platform.y + platform.height / 2) {
                    player.y = platform.y - player.height;
                    player.vy = 0;
                    player.grounded = true;
                }
                // Hitting platform from below
                else if (player.vy < 0 && player.y > platform.y + platform.height / 2) {
                    player.y = platform.y + platform.height;
                    player.vy = 0;
                }
                // Hitting platform from left
                else if (player.vx > 0 && player.x + player.width > platform.x && player.x < platform.x) {
                    player.x = platform.x - player.width;
                }
                // Hitting platform from right
                else if (player.vx < 0 && player.x < platform.x + platform.width && player.x + player.width > platform.x + platform.width) {
                    player.x = platform.x + platform.width;
                }
            }
        }
        
        // Enemy movement and collision
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            if (enemy.health <= 0) continue;
            
            enemy.animation += 0.1;
            
            // Simple AI - move back and forth
            enemy.x += enemy.speed * enemy.direction;
            
            // Change direction at edges or when hitting a wall
            let onPlatform = false;
            for (const platform of platforms) {
                if (enemy.x <= platform.x + platform.width &&
                    enemy.x + enemy.width >= platform.x &&
                    enemy.y + enemy.height >= platform.y &&
                    enemy.y + enemy.height <= platform.y + platform.height / 2) {
                    onPlatform = true;
                    
                    // Check if at edge of platform
                    if ((enemy.direction < 0 && enemy.x <= platform.x) ||
                        (enemy.direction > 0 && enemy.x + enemy.width >= platform.x + platform.width)) {
                        enemy.direction *= -1;
                    }
                    break;
                }
            }
            
            // If not on a platform, turn around
            if (!onPlatform) {
                enemy.direction *= -1;
            }
            
            // Shooting enemies
            if (enemy.shoots) {
                enemy.shootCooldown--;
                if (enemy.shootCooldown <= 0) {
                    // Shoot towards player
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 500) { // Only shoot if player is within range
                        const angle = Math.atan2(dy, dx);
                        
                        projectiles.push({
                            x: enemy.x + enemy.width / 2,
                            y: enemy.y + enemy.height / 2,
                            width: 10,
                            height: 5,
                            vx: Math.cos(angle) * enemy.projectileSpeed,
                            vy: Math.sin(angle) * enemy.projectileSpeed,
                            damage: enemy.damage / 2,
                            color: currentLevel === 1 ? "#00ff00" : 
                                  currentLevel === 2 ? "#ff0000" : "#800080",
                            fromEnemy: true,
                            type: currentLevel === 1 ? "bullet" : 
                                 currentLevel === 2 ? "dart" : "ghost"
                        });
                        enemy.shootCooldown = enemy.shootInterval;
                    }
                }
            }
            
            // Enemy collision with player
            if (!player.invincible && !player.attacking &&
                player.x + player.width > enemy.x &&
                player.x < enemy.x + enemy.width &&
                player.y + player.height > enemy.y &&
                player.y < enemy.y + enemy.height) {
                
                player.health -= enemy.damage;
                player.invincible = true;
                player.invincibleTimer = 60; // 1 second invincibility
                
                // Knockback
                if (player.x < enemy.x) {
                    player.vx = -10;
                } else {
                    player.vx = 10;
                }
                player.vy = -5;
                
                updateUI();
                
                if (player.health <= 0) {
                    gameOver = true;
                    showGameOverScreen();
                    return;
                }
            }
            
            // Player attack hits enemy
            if (player.attacking && player.attackCooldown > player.attackDuration - 5) {
                const attackX = player.facing > 0 ? player.x + player.width : player.x - player.attackRange;
                const attackWidth = player.attackRange;
                
                if (attackX < enemy.x + enemy.width &&
                    attackX + attackWidth > enemy.x &&
                    player.y + player.height > enemy.y &&
                    player.y < enemy.y + enemy.height) {
                    
                    // Fire attack does more damage
                    const damage = player.powerup === "FIRE_ATTACK" ? 
                                 player.damage * 2 : player.damage;
                    
                    enemy.health -= damage;
                    if (enemy.health <= 0) {
                        player.xp += 20;
                        score += 50;
                        enemiesDefeated++;
                        enemies.splice(i, 1);
                        checkLevelUp();
                    }
                }
            }
        }
        
        // Projectile movement and collision
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const proj = projectiles[i];
            proj.x += proj.vx;
            proj.y += proj.vy;
            
            // Remove projectiles that go off screen
            if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
                projectiles.splice(i, 1);
                continue;
            }
            
            // Enemy projectiles hit player
            if (proj.fromEnemy && !player.invincible &&
                player.x + player.width > proj.x &&
                player.x < proj.x + proj.width &&
                player.y + player.height > proj.y &&
                player.y < proj.y + proj.height) {
                
                player.health -= proj.damage;
                player.invincible = true;
                player.invincibleTimer = 60;
                projectiles.splice(i, 1);
                
                // Knockback
                if (player.x < proj.x) {
                    player.vx = -8;
                } else {
                    player.vx = 8;
                }
                player.vy = -5;
                
                updateUI();
                
                if (player.health <= 0) {
                    gameOver = true;
                    showGameOverScreen();
                    return;
                }
            }
            
            // Player attacks destroy enemy projectiles
            if (!proj.fromEnemy && player.attacking && player.attackCooldown > player.attackDuration - 5) {
                const attackX = player.facing > 0 ? player.x + player.width : player.x - player.attackRange;
                const attackWidth = player.attackRange;
                
                if (attackX < proj.x + proj.width &&
                    attackX + attackWidth > proj.x &&
                    player.y + player.height > proj.y &&
                    player.y < proj.y + proj.height) {
                    
                    projectiles.splice(i, 1);
                }
            }
        }
        
        // Trap logic
        for (const trap of traps) {
            trap.timer++;
            
            if (trap.timer >= trap.interval) {
                trap.active = !trap.active;
                trap.timer = 0;
                
                if (trap.active && trap.direction === "down") {
                    // Reset position for falling traps
                    trap.y = 0;
                }
            }
            
            // Trap movement
            if (trap.active) {
                if (trap.direction === "down") {
                    trap.y += trap.speed;
                    if (trap.y > canvas.height) {
                        trap.active = false;
                        trap.timer = 0;
                    }
                }
                
                // Trap collision with player
                if (!player.invincible &&
                    player.x + player.width > trap.x &&
                    player.x < trap.x + trap.width &&
                    player.y + player.height > trap.y &&
                    player.y < trap.y + trap.height) {
                    
                    player.health -= trap.damage;
                    player.invincible = true;
                    player.invincibleTimer = 60;
                    
                    // Knockback
                    if (trap.direction === "down") {
                        player.vy = -10;
                    }
                    
                    updateUI();
                    
                    if (player.health <= 0) {
                        gameOver = true;
                        showGameOverScreen();
                        return;
                    }
                }
            }
        }
        
        // Coin collection
        for (let i = coins.length - 1; i >= 0; i--) {
            const coin = coins[i];
            coin.animation += 0.1;
            
            if (!coin.collected &&
                player.x + player.width > coin.x &&
                player.x < coin.x + coin.width &&
                player.y + player.height > coin.y &&
                player.y < coin.y + coin.height) {
                
                coin.collected = true;
                player.gold += coin.value;
                score += coin.value;
                coins.splice(i, 1);
                updateUI();
            }
        }
        
        // Treasure collection
        for (let i = treasures.length - 1; i >= 0; i--) {
            const treasure = treasures[i];
            treasure.glow += 0.05;
            
            if (!treasure.collected &&
                player.x + player.width > treasure.x &&
                player.x < treasure.x + treasure.width &&
                player.y + player.height > treasure.y &&
                player.y < treasure.y + treasure.height) {
                
                treasure.collected = true;
                player.gold += treasure.value;
                player.xp += 30;
                score += treasure.value * 2;
                treasures.splice(i, 1);
                checkLevelUp();
                updateUI();
            }
        }
        
        // Powerup collection
        for (let i = powerups.length - 1; i >= 0; i--) {
            const powerup = powerups[i];
            powerup.animation += 0.1;
            
            if (!powerup.collected &&
                player.x + player.width > powerup.x &&
                player.x < powerup.x + powerup.width &&
                player.y + player.height > powerup.y &&
                player.y < powerup.y + powerup.height) {
                
                powerup.collected = true;
                applyPowerup(powerup.type);
                powerups.splice(i, 1);
            }
        }
        
        // Level exit
        if (levelExit) {
            levelExit.animation += 0.05;
            
            if (player.x + player.width > levelExit.x &&
                player.x < levelExit.x + levelExit.width &&
                player.y + player.height > levelExit.y &&
                player.y < levelExit.y + levelExit.height) {
                
                levelComplete = true;
                currentLevel++;
                score += 1000;
                
                if (currentLevel > maxLevel) {
                    // Game completed
                    showGameOverScreen(true);
                } else {
                    showLevelScreen();
                }
            }
        }
    }
    
    // Check for level up
    function checkLevelUp() {
        if (player.xp >= player.xpToNextLevel) {
            player.level++;
            player.xp -= player.xpToNextLevel;
            player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
            player.maxHealth += 20;
            player.health = player.maxHealth;
            player.damage += 5;
            updateUI();
            
            // Show level up effect
            powerupIndicator.textContent = "LEVEL UP!";
            powerupIndicator.style.backgroundColor = "#f8c537";
            powerupIndicator.style.display = "block";
            setTimeout(() => {
                if (powerupIndicator.textContent === "LEVEL UP!") {
                    powerupIndicator.style.display = "none";
                }
            }, 2000);
        }
    }
    
    // Update UI
    function updateUI() {
        goldDisplay.textContent = player.gold;
        levelDisplay.textContent = player.level;
        healthDisplay.textContent = player.health;
        healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
        
        // Health bar color based on health
        if (player.health < player.maxHealth * 0.3) {
            healthBar.style.background = "linear-gradient(to right, #ff0000, #ff4500)";
        } else if (player.health < player.maxHealth * 0.6) {
            healthBar.style.background = "linear-gradient(to right, #ff4500, #ffa500)";
        } else {
            healthBar.style.background = "linear-gradient(to right, #00ff00, #00cc00)";
        }
    }
    
    // Draw background layers with parallax
    function drawBackground() {
        for (const layer of backgrounds) {
            // Calculate parallax position
            const x = -(player.x * layer.speed) % canvas.width;
            
            // Draw layer twice for seamless scrolling
            ctx.drawImage(layer.canvas, x, 0, canvas.width, canvas.height);
            ctx.drawImage(layer.canvas, x + canvas.width, 0, canvas.width, canvas.height);
        }
    }
    
    // Draw game
    function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw background with parallax
        drawBackground();
        
        // Draw platforms
        for (const platform of platforms) {
            ctx.fillStyle = platform.color;
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            
            // Add some details to platforms
            ctx.fillStyle = "#5D4037";
            for (let i = 0; i < platform.width / 20; i++) {
                ctx.fillRect(
                    platform.x + i * 20 + 5, 
                    platform.y - 5, 
                    10, 
                    5
                );
            }
        }
        
        // Draw level exit
        if (levelExit) {
            ctx.fillStyle = levelExit.color;
            ctx.fillRect(levelExit.x, levelExit.y, levelExit.width, levelExit.height);
            
            // Draw door details with animation
            ctx.fillStyle = `hsl(${Math.sin(levelExit.animation) * 30 + 180}, 100%, 50%)`;
            ctx.fillRect(
                levelExit.x + 15, 
                levelExit.y + 10, 
                20, 
                40
            );
            
            // Draw glow effect
            ctx.strokeStyle = `hsla(${Math.sin(levelExit.animation) * 30 + 180}, 100%, 50%, 0.5)`;
            ctx.lineWidth = 3;
            ctx.strokeRect(
                levelExit.x - 5, 
                levelExit.y - 5, 
                levelExit.width + 10, 
                levelExit.height + 10
            );
        }
        
        // Draw coins with animation
        for (const coin of coins) {
            const yOffset = Math.sin(coin.animation) * 5;
            ctx.save();
            ctx.translate(0, yOffset);
            
            ctx.fillStyle = "#f8c537";
            ctx.beginPath();
            ctx.arc(
                coin.x + coin.width / 2, 
                coin.y + coin.height / 2, 
                coin.width / 2, 
                0, 
                Math.PI * 2
            );
            ctx.fill();
            
            ctx.strokeStyle = "#daa520";
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Add shine effect
            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.beginPath();
            ctx.arc(
                coin.x + coin.width / 2 + 3, 
                coin.y + coin.height / 2 - 3, 
                coin.width / 4, 
                0, 
                Math.PI * 2
            );
            ctx.fill();
            
            ctx.restore();
        }
        
        // Draw treasures with glow effect
        for (const treasure of treasures) {
            ctx.fillStyle = "#daa520";
            ctx.fillRect(treasure.x, treasure.y + 5, treasure.width, treasure.height - 5);
            
            ctx.fillStyle = "#f8c537";
            ctx.fillRect(treasure.x + 5, treasure.y, treasure.width - 10, 5);
            
            ctx.fillStyle = "#a82b2b";
            ctx.fillRect(treasure.x + treasure.width / 2 - 3, treasure.y, 6, 5);
            
            // Glow effect
            ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + Math.sin(treasure.glow) * 0.3})`;
            ctx.lineWidth = 3;
            ctx.strokeRect(
                treasure.x - 5, 
                treasure.y - 5, 
                treasure.width + 10, 
                treasure.height + 10
            );
        }
        
        // Draw powerups
        for (const powerup of powerups) {
            const size = 30 + Math.sin(powerup.animation) * 5;
            const x = powerup.x + (powerup.width - size) / 2;
            const y = powerup.y + (powerup.height - size) / 2;
            
            ctx.fillStyle = powerup.color;
            ctx.beginPath();
            ctx.arc(
                powerup.x + powerup.width / 2,
                powerup.y + powerup.height / 2,
                size / 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Add pulse effect
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 + Math.sin(powerup.animation) * 0.3})`;
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        // Draw enemies
        for (const enemy of enemies) {
            if (enemy.health > 0) {
                // Draw enemy with animation
                const bob = Math.sin(enemy.animation) * 3;
                
                ctx.save();
                ctx.translate(0, bob);
                
                // Body
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // Head
                ctx.fillStyle = currentLevel === 3 ? "#c0c0c0" : "#333";
                ctx.fillRect(enemy.x + 5, enemy.y - 10, enemy.width - 10, 15);
                
                // Eyes
                ctx.fillStyle = currentLevel === 3 ? "#ff0000" : "#fff";
                const eyeOffset = enemy.direction > 0 ? 5 : -5;
                ctx.fillRect(enemy.x + 10 + eyeOffset, enemy.y - 5, 4, 4);
                ctx.fillRect(enemy.x + 20 + eyeOffset, enemy.y - 5, 4, 4);
                
                // Weapon
                ctx.fillStyle = "#555";
                if (enemy.type === "shooter") {
                    ctx.fillRect(enemy.x + (enemy.direction > 0 ? enemy.width : -10), enemy.y + 15, 10, 5);
                } else {
                    ctx.fillRect(enemy.x + (enemy.direction > 0 ? enemy.width : -15), enemy.y + 10, 15, 5);
                }
                
                // Health bar
                const healthPercent = enemy.health / enemy.maxHealth;
                ctx.fillStyle = "#ff0000";
                ctx.fillRect(enemy.x, enemy.y - 15, enemy.width, 5);
                ctx.fillStyle = "#00ff00";
                ctx.fillRect(enemy.x, enemy.y - 15, enemy.width * healthPercent, 5);
                
                ctx.restore();
            }
        }
        
        // Draw projectiles
        for (const proj of projectiles) {
            // Different styles for different projectile types
            if (proj.type === "bullet") {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.width, 0, Math.PI * 2);
                ctx.fill();
            } 
            else if (proj.type === "dart") {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.moveTo(proj.x, proj.y);
                ctx.lineTo(proj.x + proj.width, proj.y + proj.height / 2);
                ctx.lineTo(proj.x, proj.y + proj.height);
                ctx.closePath();
                ctx.fill();
            } 
            else if (proj.type === "ghost") {
                ctx.fillStyle = `rgba(138, 43, 226, 0.7)`;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.width, 0, Math.PI * 2);
                ctx.fill();
                
                // Wavy effect
                ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i < Math.PI * 2; i += 0.2) {
                    const r = proj.width + Math.sin(i * 3 + Date.now() / 200) * 2;
                    const x = proj.x + Math.cos(i) * r;
                    const y = proj.y + Math.sin(i) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
        }
        
        // Draw traps
        for (const trap of traps) {
            if (trap.active) {
                if (trap.type === "dart") {
                    ctx.fillStyle = "#00ff00";
                    ctx.beginPath();
                    ctx.moveTo(trap.x, trap.y);
                    ctx.lineTo(trap.x + trap.width, trap.y + trap.height / 2);
                    ctx.lineTo(trap.x, trap.y + trap.height);
                    ctx.closePath();
                    ctx.fill();
                } 
                else if (trap.type === "rock") {
                    ctx.fillStyle = "#555";
                    ctx.beginPath();
                    ctx.arc(
                        trap.x + trap.width / 2,
                        trap.y + trap.height / 2,
                        trap.width / 2,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Rock details
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(
                        trap.x + trap.width / 2,
                        trap.y + trap.height / 2,
                        trap.width / 2 - 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.stroke();
                }
            }
        }
        
        // Draw player
        ctx.save();
        
        // Apply invincibility flash
        if (player.invincible && Math.floor(player.invincibleTimer / 5) % 2 === 0) {
            ctx.filter = "drop-shadow(0 0 5px white)";
        }
        
        // Draw player sprite
        if (player.facing < 0) {
            ctx.translate(player.x + player.width, player.y);
            ctx.scale(-1, 1);
            ctx.drawImage(player.sprite, 0, 0, player.width, player.height);
        } else {
            ctx.drawImage(player.sprite, player.x, player.y, player.width, player.height);
        }
        
        // Draw attack effect
        if (player.attacking && player.attackCooldown > player.attackDuration - 5) {
            ctx.save();
            if (player.facing < 0) {
                ctx.translate(player.x - player.attackRange, player.y);
                ctx.scale(1, 1);
            } else {
                ctx.translate(player.x + player.width, player.y);
            }
            
            // Different attack effects based on powerup
            if (player.powerup === "FIRE_ATTACK") {
                ctx.globalCompositeOperation = "lighter";
                ctx.drawImage(player.attackSprite, 0, 0, player.attackRange, player.height);
            } else {
                ctx.drawImage(player.attackSprite, 0, 0, player.attackRange, player.height);
            }
            ctx.restore();
        }
        
        ctx.restore();
    }
    
    // Main game loop
    function gameLoop() {
        if (!gameStarted || gameOver || levelTransition) return;
        
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }
    
    // Initialize the game
    initGame();
});
</script>
</body>
</html>
